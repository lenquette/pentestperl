#!/usr/bin/perl -w
use strict;
use Net::Pcap qw( :functions );
#use Net::Pcap;
use Net::Frame::Device;
use Net::Netmask;
use Net::Frame::Dump::Online;
use Net::ARP;
use Net::Frame::Simple;


my $err = "";

# The lookupdev() function is provided by Net::Pcap, which can determine the network interface card (NIC) to be used for scanning 
# it can be initialized manually: my $dev = "eth0"; 
#my $dev = pcap_lookupdev(\$err); # from Net::Pcap
my $dev ="enp1s0";

# $devProp object is used to determine the NIC's network information using the ip, gatewayIp, mac and subnet
my $devProp = Net::Frame::Device->new(dev => $dev);
my $ip = $devProp->ip;
my $gateway = $devProp->gatewayIp;
my $netmask = new Net::Netmask($devProp->subnet);
my $mac = $devProp->mac;
my $netblock = $ip . ":" . $netmask->mask();

# $filterStr is a filter string which uses a simple tcpdump filter syntax which will be passed to $pcap to filter out everthing that is not an ARP packet and set to our live host's IP addresse
my $filterStr = "arp and dst host ".$ip;

# promisc is a boolean value to set the network adapter to the Promiscuous mode
# unlikOnStop is a boolean value to delete a generated .pcap file
# timeourOnNext is the seconds left before timing out after the last call to the next() method 
my $pcap = Net::Frame::Dump::Online->new(
dev => $dev,
filter => $filterStr,
promisc => 0,
unlinkOnStop => 1,
timeoutOnNext => 10 # waiting for ARP responses
);

# start the $pcap object
$pcap->start;



print "Gateway IP: ",$gateway,"\n","Starting scan\n";
for my $ipts ($netmask->enumerate){
Net::ARP::send_packet(
$dev,
$ip,
$ipts,
$mac,
"ff:ff:ff:ff:ff:ff", # broadcast
"request");
}

until ($pcap->timeout){
if (my $next = $pcap->next){ # frame according to $filterStr
my $fref = Net::Frame::Simple->newFromDump($next);
# we donâ€™t have to worry about the operation codes 1, or 2
# because of the $filterStr
print $fref->ref->{ARP}->srcIp," is alive\n";
}
}
END{ print "Exiting\n"; $pcap->stop; }
